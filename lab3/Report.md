# Отчёт по лабораторной работе №3

**Университет ИТМО**  
**Факультет программной инженерии и компьютерной техники**  

**Студент:** Владимиров Владислав Александрович
**Группа:** P3322

**Тема:** Потоковая обработка данных с интерполяцией
**Дисциплина:** Функциональное программирование

---

## Требования к разработанному ПО

### Цель работы
Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой.

Реализовать программу интерполяции, работающую в потоковом режиме, с возможностью выбора алгоритма интерполяции через командную строку.

### Функциональные требования

1. **Алгоритмы интерполяции:**
   - Линейная интерполяция
   - Интерполяция Ньютона с настраиваемым количеством точек

2. **Потоковая обработка:**
   - Чтение данных из стандартного ввода
   - Вывод результатов в стандартный вывод
   - Обработка данных по мере поступления
   - Работа в режиме скользящего окна

3. **Командная строка:**
   - Выбор алгоритма интерполяции (`--linear`, `--newton`)
   - Настройка шага дискретизации (`--step`)
   - Количество точек для алгоритма Ньютона (`-n`)

4. **Формат данных:**
   - Входные данные: текстовый формат `x y\n`
   - Разделители: пробел, табуляция, точка с запятой
   - Выходные данные: `method: x y`

### Технические требования

- **Язык программирования:** Gleam
- **Функциональный стиль:** чистые функции, неизменяемые данные
- **Разделение ответственности:** ввод/вывод отделён от алгоритмов
- **Идиоматичный стиль программирования**

---

## Ключевые элементы реализации

### Основные типы данных

```gleam
pub type Point {
  Point(x: Float, y: Float)
}

pub type InterpolationMethod {
  Linear
  Newton(n: Int)
}

pub type StreamState {
  StreamState(
    points: List(Point),
    last_x: Option(Float),
    step: Float,
    methods: List(InterpolationMethod),
  )
}
```

### Линейная интерполяция

Базовая формула:
```
y = y0 + (y1 - y0) * (x - x0) / (x1 - x0)
```

Реализация:
```gleam
pub fn linear_interpolate(p0: Point, p1: Point, x: Float) -> Float {
  let dx = p1.x -. p0.x
  case dx == 0.0 {
    True -> p0.y
    False -> p0.y +. { p1.y -. p0.y } *. { x -. p0.x } /. dx
  }
}
```

### Интерполяция Ньютона

Использует метод разделённых разностей для построения полинома:
```
P(x) = c0 + c1*(x-x0) + c2*(x-x0)*(x-x1) + ...
```

Вычисление разделённых разностей:
```gleam
pub fn divided_differences(points: List(Point)) -> List(Float) {
  case points {
    [] -> []
    [p] -> [p.y]
    _ -> {
      let initial_column = list.map(points, fn(p) { p.y })
      let xs = list.map(points, fn(p) { p.x })
      build_dd_table(xs, xs, initial_column, [])
    }
  }
}
```

### Потоковая обработка

Основной цикл обработки входных данных:
```gleam
fn process_input_loop(state: StreamState) -> Nil {
  case read_line_ffi() {
    Error(_) -> {
      let final_results = stream_processor.finalize(state)
      print_results(final_results)
    }
    Ok(line) -> {
      case parser.parse_line(line) {
        Ok(point) -> {
          let #(new_state, results) =
            stream_processor.process_point(state, point)
          print_results(results)
          process_input_loop(new_state)
        }
        Error(_) -> process_input_loop(state)
      }
    }
  }
}
```

Механизм скользящего окна реализован в функции `process_point`:
```gleam
pub fn process_point(
  state: StreamState,
  point: Point,
) -> #(StreamState, List(InterpolationResult)) {
  let new_points = insert_sorted(state.points, point)
  let #(results, new_last_x) =
    process_all_methods(state.methods, new_points, state.last_x, state.step, [])
  let new_state =
    StreamState(..state, points: new_points, last_x: Some(new_last_x))
  #(new_state, results)
}
```

### Парсинг командной строки

```gleam
pub fn parse_args(args: List(String)) -> Result(Config, ParseError) {
  parse_args_loop(args, Config(methods: [], step: 1.0, help: False))
  |> result.try(validate_config)
}
```

Поддерживаемые опции:
- `--linear` / `-l` - линейная интерполяция
- `--newton N` / `-n N` - интерполяция Ньютона с N точками
- `--step STEP` / `-s STEP` - шаг дискретизации
- `--help` / `-h` - справка

### Архитектура программы

```
parser.gleam         - Парсинг входных данных
  ↓
stream_processor.gleam - Потоковая обработка (скользящее окно)
  ↓
interpolation.gleam   - Алгоритмы интерполяции
  ↓
lab3.gleam           - Главный модуль, ввод/вывод
  ↑
cli.gleam            - Обработка аргументов командной строки
```

---

## Примеры ввода/вывода

### Пример 1: Линейная интерполяция

**Команда:**
```bash
gleam run -- --linear --step 0.5
```

**Ввод:**
```
0 0
1 1
2 2
3 3
```

**Вывод:**
```
linear: 0 0
linear: 0.5 0.5
linear: 1 1
linear: 1.5 1.5
linear: 2 2
linear: 2.5 2.5
linear: 3 3
```

### Пример 2: Интерполяция Ньютона

**Команда:**
```bash
gleam run -- --newton 3 --step 0.5
```

**Ввод:**
```
0 0
1 1
2 4
3 9
```

**Вывод:**
```
newton: 0 0
newton: 0.5 0.25
newton: 1 1
newton: 1.5 2.25
newton: 2 4
newton: 2.5 6.25
newton: 3 9
```

### Пример 3: Несколько методов одновременно

**Команда:**
```bash
gleam run -- --linear --newton 4 --step 1
```

**Ввод:**
```
0 0
2 4
4 16
6 36
```

**Вывод:**
```
linear: 0 0
linear: 1 2
linear: 2 4
newton: 0 0
newton: 1 1
newton: 2 4
linear: 3 10
linear: 4 16
newton: 3 9
newton: 4 16
linear: 5 26
linear: 6 36
newton: 5 25
newton: 6 36
```

---

## Выводы

В ходе выполнения лабораторной работы были получены практические навыки работы с потоковой обработкой данных в функциональном стиле.

### Использованные приёмы программирования:

1. **Функциональная композиция** - разделение программы на чистые функции, каждая из которых решает одну задачу

2. **Неизменяемые данные** - все структуры данных неизменяемы, состояние передаётся явно через параметры функций

3. **Pattern matching** - широкое использование сопоставления с образцом для обработки различных случаев

4. **Рекурсия вместо циклов** - основной цикл программы реализован через хвостовую рекурсию

5. **Разделение ответственности** - чёткое разделение между вводом/выводом, парсингом, обработкой и алгоритмами

6. **Монадический стиль** - использование `Result` для обработки ошибок без исключений

7. **Потоковая обработка** - данные обрабатываются по мере поступления, без загрузки всего набора в память

### Преимущества функционального подхода:

- **Тестируемость** - чистые функции легко тестировать изолированно
- **Предсказуемость** - отсутствие побочных эффектов упрощает отладку
- **Модульность** - каждый модуль может быть заменён или расширен независимо
- **Читаемость** - декларативный стиль делает код понятнее